Yasmine Brooks
2/2/2020
NIM Project

/*NOTE: This has to be compiled with C++11 (c++ -std=c++11 nim.cpp -o nim)*/

There are three important functions that run the core of the NIM game. The first is the playNim() function. This function runs the game of NIM itself by alternating the player input between Computer and Human and vice versa. This function will use the next two functions outlined in this file.
playNim() Algorithm: 
  1)Read in unsafe player moves from the "unsafe" file 
  2)Get initial game information such as number of coins in each pile and which player starts.
  3)Play the game
    3a) ask current player (human or computer) for their move.
    3b) check if current player lost the game (took last coin)
    3c) if the game has not been lost, ask the other player for their move 
    3d) check if this player has lost the game
    3e) if the game has not been lost, repeat these steps
  4)Add all the new unsafe game positions to the "unsafe" file
  
The next important function is the getHumanPlay function. This function gets the human player's next move. 
  getHumanPlay() Algorithm:
  1)Ask the human which pile and how many coins they are going to take. 
  2)If the human input is valid, update the game(subtract amount from pile)
  3)Print the current game state

The last important function is the getMachinePlay function. This function gets the computer player's next move. 
getMachinePlay() Algorithm:
  1) generate up to 9 potential next moves for the computer to make
  2) for each of those potential next moves
    2a)check if the move is classified as a safe move
    2b) if the move is safe, add it to a safe vector
    2c) if the move is not safe, add it to an unsafe vector and generate the 9 moves that could have led to arriving at the state to add to "unsafe" file
  3)if the safe vector has a size of 0 (no safe potential next moves)
    3a)find the smallest unsafe move that the computer can make (i.e. find the pile where the computer can take the least amount coins from to maximize human's room for error)
  4) if the safe vector has a size greater than 0
    4a) find the largest safe next move that can be made (i.e. find the pile where the computer can take the most coins to maximize the potential for the human to be in an unsafe spot).
    
These are the three functions that hold the main operations of the NIM gameplay. I used a stl::set to make lookup easier and quicker for the unsafe moves read in from the file, instead of having to traverse through a big file or other sequential container. I also used a GameState to house what was in each pile. However, I should have implemented it as an array instead of three individual integers so that manipulating the piles would not have taken as many loops or functions.